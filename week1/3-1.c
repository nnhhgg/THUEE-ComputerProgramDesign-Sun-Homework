// （探究题，选做）编写程序，将一段文字中出现的所有英文阿拉伯数字和中文阿拉伯数字转化成（按照人们习惯的读音）中文。
// 比如：“我去购物中心花2021元买了一块手表”，其中的：“2021”是英文阿拉伯数字，
// 每个数字占一个字节，应该按照读音转化为：“两千零二十一”。
// 也可能写作：“我去购物中心花２０２１元买了一块手表”，
// 其中的“２０２１”是中文格式的阿拉伯数字，每个数字占两个字节，也应该按照读音转化为：“两千零二十一”。
// 又比如：“他花108050元买了一辆新电动车"，其中的："108050"应该按照人们读音习惯转化为："十万八千零五十"。
// 转化单位包括：亿、万、千、百、十......
// 更进一步，可以转化带小数的数字，例如将："121.14156“ 转化为:"一百二十一点一四一五六"。
// 如何判断是否是英文阿拉伯数字和中文阿拉伯数字:
// for(k=0; k<strlen(str); k++)
//     if (str[k]>=‘0’ && str[k]<=‘9’)
// unsigned char zero[]="０", nine[]="９";
// for(k=0; k<strlen(str); k++)
//     if ((str[k]>=zero[0] && str[k]<=nine[0]) && (str[k+1]>=zero[1]) && str[k+1]<=nine[1]))
// 注意：
// ①在VS上调试程序时，用GBK编码方式（两个字节），不要用Unicode方式（多字节）。
// ②不要出现跨字的问题，因为每个汉字占两个字节，顺序向后遍历字符串时，
//  容易出现把第一个汉字的第二个字节与第二个汉字的第一个字节当作一个汉字来判断，出现跨字错误。
// 我们这里用utf-8编码方式。

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

int main()
{
    char num[30] = {0};
    int n1[15] = {0}, n2[15] = {0};
    char c;
    char Cnum[10][20] =
        {
            {"零"},
            {"一"},
            {"二"},
            {"三"},
            {"四"},
            {"五"},
            {"六"},
            {"七"},
            {"八"},
            {"九"}};
    char Cpos[10][20] =
        {
            {"个"},
            {"十"},
            {"百"},
            {"千"},
            {"万"},
            {"十万"},
            {"百万"},
            {"千万"},
            {"亿"}};
    FILE *fin, *fout;
    int i, j1, j;

    fin = fopen("3.dat", "r");
    fout = fopen("3out.dat", "w");
    c = fgetc(fin);
    while (c != EOF)
    {
        if (isdigit(c))
        {
            int i = 0;
            while (isdigit(c) || (c == '.'))
            {

                num[i] = c;
                i++;
                c = fgetc(fin);
            }
            num[i] = '\0';
            // 将数录入到num这一个字符型数组中；
            // 下面将num分为小数点前后两部分录入到n1和n2这两个整形数组中。
            i = 0;
            while (num[i] != '\0' && num[i] != '.')
            {

                n1[j] = num[i] - '0';
                i++;
                j++;
                j1 = j; // j1储存了n1有多少位；
            }
            j = 0;
            if (num[i++] == '.')
            {

                n2[j] = num[i] - '0';
                i++;
                j++;
            }
            // 下面开始生成；为了方便起见，文本中的数字不=不会出现大于9999的数字。
            i = 0;
            for (int x = 0; x < j1; x++)
            {
                fprintf(fout, "%s", Cnum[n1[x]]);
                fprintf(fout, "%s", Cpos[j1 - x - 1]);
            }
            fprintf(fout, "\n");
        }
        else
            c = fgetc(fin);
    }
    fclose(fin);
    fclose(fout);
    return (0);
}